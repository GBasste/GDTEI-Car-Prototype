#include <iostream>
#include <thread>
#include <chrono>
#include <string>
#include <cmath>
#include <iomanip>
#include <memory>

// Simulaci√≥n de Pin GPIO para C++ est√°ndar
class Pin {
private:
    int pin_number;
    bool is_output;
    
public:
    static const bool OUT = true;
    static const bool IN = false;
    
    Pin(int pin, bool mode) : pin_number(pin), is_output(mode) {
        std::cout << "Pin " << pin_number << " configurado como " 
                  << (mode ? "OUTPUT" : "INPUT") << std::endl;
    }
    
    int get_pin() const { return pin_number; }
};

// Simulaci√≥n de PWM para C++ est√°ndar
class PWM {
private:
    std::unique_ptr<Pin> pin;
    int frequency;
    int current_duty;
    bool active;
    
public:
    PWM(int pin_number) : frequency(1000), current_duty(0), active(false) {
        pin = std::make_unique<Pin>(pin_number, Pin::OUT);
        std::cout << "PWM creado en pin " << pin_number << std::endl;
    }
    
    // Constructor que recibe Pin por referencia (como en Python)
    PWM(Pin& p) : frequency(1000), current_duty(0), active(false) {
        // En este caso, no manejamos la memoria del pin
        std::cout << "PWM creado en pin " << p.get_pin() << std::endl;
    }
    
    void freq(int f) {
        frequency = f;
        std::cout << "PWM frecuencia configurada: " << frequency << " Hz" << std::endl;
    }
    
    void duty(int d) {
        current_duty = d;
        if (d > 0) {
            active = true;
        } else {
            active = false;
        }
        
        // Solo mostrar cuando hay cambios significativos o es 0
        static int last_shown = -1;
        if (d == 0 || abs(d - last_shown) >= 50) {
            std::cout << "PWM duty: " << current_duty << "/1023 (" 
                      << std::fixed << std::setprecision(1) 
                      << (float(d)/1023.0f*100) << "%)" << std::endl;
            last_shown = d;
        }
    }
    
    int get_duty() const { return current_duty; }
    bool is_active() const { return active; }
    int get_frequency() const { return frequency; }
};

// Funci√≥n para delay en segundos con decimales
void sleep(float seconds) {
    int milliseconds = static_cast<int>(seconds * 1000);
    std::this_thread::sleep_for(std::chrono::milliseconds(milliseconds));
}

// Enumeraci√≥n para tipos de aceleraci√≥n
enum class TipoAceleracion {
    LINEAL,
    SUAVE,
    RAPIDO
};

// Funci√≥n para convertir string a enum
TipoAceleracion string_to_tipo(const std::string& tipo) {
    if (tipo == "suave") return TipoAceleracion::SUAVE;
    if (tipo == "rapido") return TipoAceleracion::RAPIDO;
    return TipoAceleracion::LINEAL; // Por defecto
}

// ========================================
// FUNCI√ìN DE ACELERACI√ìN
// ========================================

std::unique_ptr<PWM> acelerar_pwm(int pin_numero, 
                                  int velocidad_inicial = 0, 
                                  int velocidad_final = 1023, 
                                  float tiempo_total = 2.0f, 
                                  const std::string& tipo = "lineal") {
    /**
     * Acelera PWM gradualmente desde velocidad inicial hasta final
     * 
     * Par√°metros:
     * - pin_numero: N√∫mero del pin GPIO
     * - velocidad_inicial: Valor PWM inicial (0-1023)
     * - velocidad_final: Valor PWM final (0-1023)  
     * - tiempo_total: Tiempo total de aceleraci√≥n en segundos
     * - tipo: "lineal", "suave", "rapido"
     * 
     * Retorna: Objeto PWM configurado al valor final
     */
    
    // Crear objeto PWM
    auto pwm = std::make_unique<PWM>(pin_numero);
    pwm->freq(1000);  // Frecuencia 1kHz
    
    // Calcular pasos
    int diferencia = velocidad_final - velocidad_inicial;
    int pasos = 50;  // N√∫mero de pasos para suavidad
    float incremento = static_cast<float>(diferencia) / pasos;
    float delay = tiempo_total / pasos;
    
    std::cout << "üöÄ Acelerando PWM Pin " << pin_numero << std::endl;
    std::cout << "   " << velocidad_inicial << " ‚Üí " << velocidad_final 
              << " en " << tiempo_total << "s" << std::endl;
    
    // Establecer velocidad inicial
    pwm->duty(velocidad_inicial);
    
    TipoAceleracion tipo_enum = string_to_tipo(tipo);
    
    // Acelerar gradualmente
    for (int paso = 0; paso <= pasos; ++paso) {
        float valor;
        
        switch (tipo_enum) {
            case TipoAceleracion::LINEAL: {
                // Aceleraci√≥n lineal constante
                valor = velocidad_inicial + (incremento * paso);
                break;
            }
            
            case TipoAceleracion::SUAVE: {
                // Aceleraci√≥n suave (curva seno)
                float progreso = static_cast<float>(paso) / pasos;
                float factor_suave = std::sin(progreso * M_PI / 2.0f);
                valor = velocidad_inicial + (diferencia * factor_suave);
                break;
            }
            
            case TipoAceleracion::RAPIDO: {
                // Aceleraci√≥n r√°pida al inicio, lenta al final
                float progreso = static_cast<float>(paso) / pasos;
                float factor_rapido = std::sqrt(progreso);
                valor = velocidad_inicial + (diferencia * factor_rapido);
                break;
            }
        }
        
        // Aplicar valor PWM
        pwm->duty(static_cast<int>(valor));
        
        // Mostrar progreso cada 10 pasos
        if (paso % 10 == 0) {
            float porcentaje = (static_cast<float>(paso) / pasos) * 100.0f;
            std::cout << "   " << std::setw(3) << std::fixed << std::setprecision(0) 
                      << porcentaje << "% - PWM: " << static_cast<int>(valor) << std::endl;
        }
        
        sleep(delay);
    }
    
    std::cout << "‚úÖ Aceleraci√≥n completada - PWM: " << velocidad_final << std::endl;
    return pwm;
}

// ========================================
// FUNCI√ìN DE DESACELERACI√ìN
// ========================================

int desacelerar_pwm(PWM& pwm_obj, int velocidad_final = 0, float tiempo_total = 1.0f) {
    /**
     * Desacelera PWM gradualmente hasta velocidad final
     * 
     * Par√°metros:
     * - pwm_obj: Objeto PWM ya creado
     * - velocidad_final: Valor PWM final (generalmente 0)
     * - tiempo_total: Tiempo de desaceleraci√≥n
     * 
     * Retorna: Valor final aplicado
     */
    
    // Obtener velocidad actual
    int velocidad_actual = pwm_obj.get_duty();
    if (velocidad_actual == 0) {
        velocidad_actual = 1023; // Asumir m√°xima si est√° en 0
    }
    
    int diferencia = velocidad_actual - velocidad_final;
    int pasos = 30;
    float incremento = static_cast<float>(diferencia) / pasos;
    float delay = tiempo_total / pasos;
    
    std::cout << "üõë Desacelerando PWM" << std::endl;
    std::cout << "   " << velocidad_actual << " ‚Üí " << velocidad_final 
              << " en " << tiempo_total << "s" << std::endl;
    
    // Desacelerar gradualmente
    for (int paso = 0; paso <= pasos; ++paso) {
        float valor = velocidad_actual - (incremento * paso);
        pwm_obj.duty(static_cast<int>(valor));
        
        if (paso % 10 == 0) {
            float porcentaje = (static_cast<float>(paso) / pasos) * 100.0f;
            std::cout << "   " << std::setw(3) << std::fixed << std::setprecision(0) 
                      << porcentaje << "% - PWM: " << static_cast<int>(valor) << std::endl;
        }
        
        sleep(delay);
    }
    
    std::cout << "‚úÖ Desaceleraci√≥n completada - PWM: " << velocidad_final << std::endl;
    return velocidad_final;
}

// ========================================
// FUNCIONES DE DEMOSTRACI√ìN
// ========================================

void demo_aceleracion_simple() {
    std::cout << "\n=== DEMO: ACELERACI√ìN SIMPLE ===" << std::endl;
    
    // Acelerar linealmente
    auto pwm = acelerar_pwm(18, 0, 1023, 3.0f, "lineal");
    
    sleep(2.0f);  // Mantener velocidad m√°xima
    
    // Desacelerar
    desacelerar_pwm(*pwm, 0, 2.0f);
}

void demo_tipos_aceleracion() {
    std::cout << "\n=== DEMO: TIPOS DE ACELERACI√ìN ===" << std::endl;
    
    std::vector<std::string> tipos = {"lineal", "suave", "rapido"};
    
    for (const auto& tipo : tipos) {
        std::cout << "\n--- Probando aceleraci√≥n: " << tipo << " ---" << std::endl;
        
        auto pwm = acelerar_pwm(19, 100, 900, 2.5f, tipo);
        sleep(1.0f);
        desacelerar_pwm(*pwm, 0, 1.5f);
        
        sleep(1.0f);  // Pausa entre demos
    }
}

void demo_control_motor() {
    std::cout << "\n=== DEMO: CONTROL DE MOTOR ===" << std::endl;
    
    // Simular arranque suave de motor
    std::cout << "Arranque suave del motor..." << std::endl;
    auto motor = acelerar_pwm(21, 0, 800, 3.0f, "suave");
    
    std::cout << "Motor funcionando a velocidad constante..." << std::endl;
    sleep(5.0f);
    
    std::cout << "Frenado gradual del motor..." << std::endl;
    desacelerar_pwm(*motor, 0, 2.0f);
}

void ejecutar_demos_pwm() {
    std::cout << "=== SISTEMA DE ACELERACI√ìN PWM ===" << std::endl;
    std::cout << "Demostrando control suave de PWM con diferentes curvas\n" << std::endl;
    
    try {
        // Demo 1: Aceleraci√≥n simple
        demo_aceleracion_simple();
        sleep(2.0f);
        
        // Demo 2: Diferentes tipos de aceleraci√≥n
        demo_tipos_aceleracion();
        sleep(2.0f);
        
        // Demo 3: Control de motor realista
        demo_control_motor();
        
        std::cout << "\n‚úÖ Todas las demostraciones completadas exitosamente!" << std::endl;
        
    } catch (const std::exception& e) {
        std::cout << "‚ùå Error durante la demostraci√≥n: " << e.what() << std::endl;
    }
}

// Funci√≥n principal
int main() {
    std::cout << "=== CONTROL DE ACELERACI√ìN PWM C++ ===" << std::endl;
    
    ejecutar_demos_pwm();
    
    return 0;
}