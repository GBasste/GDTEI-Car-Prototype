#include <iostream>
#include <thread>
#include <chrono>
#include <cmath>
#include <random>

// Simulación de ADC para C++ estándar
class ADC {
private:
    int pin_number;
    int resolution;
    float max_voltage;
    std::default_random_engine generator;
    std::uniform_real_distribution<float> voltage_dist;
    
public:
    // Constantes para atenuación (simuladas)
    static const int ATTN_11DB = 3;
    static const int WIDTH_12BIT = 12;
    
    ADC(int pin) : pin_number(pin), resolution(4095), max_voltage(3.3), 
                   voltage_dist(0.0, 5.0) {
        std::cout << "ADC inicializado en pin " << pin_number << std::endl;
    }
    
    void atten(int attenuation) {
        if (attenuation == ATTN_11DB) {
            max_voltage = 3.6;
            std::cout << "Atenuación configurada para ~3.6V" << std::endl;
        }
    }
    
    void width(int width) {
        if (width == WIDTH_12BIT) {
            resolution = 4095;
            std::cout << "Resolución configurada a 12 bits (0-4095)" << std::endl;
        }
    }
    
    int read() {
        // Simulación de lectura ADC (en hardware real esto leería el pin)
        float simulated_voltage = voltage_dist(generator);
        int adc_value = static_cast<int>((simulated_voltage / max_voltage) * resolution);
        
        // Limitar valores dentro del rango válido
        if (adc_value > resolution) adc_value = resolution;
        if (adc_value < 0) adc_value = 0;
        
        return adc_value;
    }
};

// Simulación de Pin GPIO para C++ estándar
class Pin {
private:
    int pin_number;
    bool is_output;
    bool state;
    
public:
    static const bool OUT = true;
    static const bool IN = false;
    
    Pin(int pin, bool mode) : pin_number(pin), is_output(mode), state(false) {
        std::cout << "Pin " << pin_number << " configurado como " 
                  << (mode ? "OUTPUT" : "INPUT") << std::endl;
    }
    
    void value(int val) {
        if (is_output) {
            state = (val != 0);
            std::cout << "Pin " << pin_number << " -> " 
                      << (state ? "HIGH" : "LOW") << std::endl;
        }
    }
    
    int value() const {
        return state ? 1 : 0;
    }
};

// Función para delay en milisegundos
void delay_ms(int milliseconds) {
    std::this_thread::sleep_for(std::chrono::milliseconds(milliseconds));
}

// Función para delay en segundos con decimales
void delay_s(float seconds) {
    int milliseconds = static_cast<int>(seconds * 1000);
    std::this_thread::sleep_for(std::chrono::milliseconds(milliseconds));
}

// === CONFIGURACIÓN GLOBAL ===
ADC adc(34);
Pin rele(26, Pin::OUT);

// === CONFIGURACIÓN DEL DIVISOR DE VOLTAJE ===
// R1 = 68kΩ, R2 = 20kΩ → factor = (R1 + R2)/R2 = 4.7
const float factor = 4.7f;

void inicializar_adc_rele() {
    std::cout << "=== CONFIGURACIÓN ADC Y RELÉ ===" << std::endl;
    
    // === CONFIGURACIÓN ADC (GPIO34) ===
    adc.atten(ADC::ATTN_11DB);    // Para leer hasta ~3.6V
    adc.width(ADC::WIDTH_12BIT);  // Resolución 12 bits (0-4095)
    
    // === CONFIGURACIÓN DEL RELÉ ===
    // IN5 del módulo de 8 relés conectado al GPIO26 del ESP32
    rele.value(1);  // Inicialmente desactivado (relé OFF si se activa con LOW)
    
    std::cout << "Sistema inicializado correctamente" << std::endl;
    std::cout << "Factor de divisor de voltaje: " << factor << std::endl;
}

void leer_adc() {
    int valor_adc = adc.read();
    float voltaje_adc = valor_adc * (3.3f / 4095.0f);
    float voltaje_real = voltaje_adc * factor;
    
    std::cout << "Voltaje real: " << std::round(voltaje_real * 100) / 100.0f << " V" << std::endl;
    
    if (voltaje_real > 3.5f) {
        rele.value(0);  // ACTIVAR relé (LOW)
        std::cout << "RELÉ ACTIVADO" << std::endl;
    } else {
        rele.value(1);  // DESACTIVAR relé (HIGH)
        std::cout << "RELÉ DESACTIVADO" << std::endl;
    }
    
    delay_s(0.5f);
}

void ejecutar_control_voltaje() {
    inicializar_adc_rele();
    
    std::cout << "\n=== BUCLE PRINCIPAL ===" << std::endl;
    std::cout << "Iniciando monitoreo de voltaje..." << std::endl;
    std::cout << "Presiona Ctrl+C para detener\n" << std::endl;
    
    // Bucle infinito (equivalente al while True de Python)
    while (true) {
        leer_adc();
    }
}

// Función principal para testing (opcional)
int main() {
    try {
        ejecutar_control_voltaje();
    } catch (const std::exception& e) {
        std::cout << "Error: " << e.what() << std::endl;
        return 1;
    }
    
    return 0;
}